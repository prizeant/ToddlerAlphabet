<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alphabet Flashcards</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: pan-y;
        }
        
        .flashcard-container {
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const AlphabetFlashcards = () => {
          // Load saved data from localStorage
          const loadSavedData = () => {
            try {
              const savedData = localStorage.getItem('alphabet-flashcards-data');
              if (savedData) {
                const parsed = JSON.parse(savedData);
                return {
                  currentSet: parsed.currentSet || ['A', 'B', 'C', 'D', 'E'],
                  currentCardIndex: parsed.currentCardIndex || 0,
                  scores: parsed.scores || {},
                  successThreshold: parsed.successThreshold || 3
                };
              }
            } catch (error) {
              console.log('Error loading saved data:', error);
            }
            return {
              currentSet: ['A', 'B', 'C', 'D', 'E'],
              currentCardIndex: 0,
              scores: {},
              successThreshold: 3
            };
          };

          const savedData = loadSavedData();
          const [currentSet, setCurrentSet] = useState(savedData.currentSet);
          const [currentCardIndex, setCurrentCardIndex] = useState(savedData.currentCardIndex);
          const [scores, setScores] = useState(savedData.scores);
          const [isDragging, setIsDragging] = useState(false);
          const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [showSettings, setShowSettings] = useState(false);
          const [successThreshold, setSuccessThreshold] = useState(savedData.successThreshold);
          const cardRef = useRef(null);

          // Save data to localStorage whenever state changes
          const saveData = () => {
            try {
              const dataToSave = {
                currentSet,
                currentCardIndex,
                scores,
                successThreshold,
                lastSaved: new Date().toISOString()
              };
              localStorage.setItem('alphabet-flashcards-data', JSON.stringify(dataToSave));
            } catch (error) {
              console.log('Error saving data:', error);
            }
          };

          // Auto-save when important data changes
          useEffect(() => {
            saveData();
          }, [currentSet, currentCardIndex, scores, successThreshold]);

          const allLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
          
          const currentLetter = currentSet[currentCardIndex];

          const handleResponse = (isCorrect) => {
            const letter = currentLetter;
            const currentScore = scores[letter] || 0;
            
            let newScore;
            if (isCorrect) {
              newScore = currentScore + 1;
            } else {
              newScore = 0; // Reset to 0 on wrong answer
            }
            
            const updatedScores = {
              ...scores,
              [letter]: newScore
            };
            
            setScores(updatedScores);

            // Check if letter is now mastered
            if (newScore >= successThreshold) {
              // Replace the mastered letter with a new one
              const masteredLetterIndex = currentSet.indexOf(letter);
              const availableLetters = allLetters.filter(l => 
                !currentSet.includes(l) && (updatedScores[l] || 0) < successThreshold
              );
              
              if (availableLetters.length > 0) {
                // Replace with a new letter
                const newLetter = availableLetters[0];
                const newSet = [...currentSet];
                newSet[masteredLetterIndex] = newLetter;
                setCurrentSet(newSet);
              }
            }

            // Move to next card
            setCurrentCardIndex((prev) => (prev + 1) % currentSet.length);
          };

          const handleMouseDown = (e) => {
            setIsDragging(true);
            setStartPos({ x: e.clientX, y: e.clientY });
            setDragOffset({ x: 0, y: 0 });
          };

          const handleMouseMove = (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - startPos.x;
            setDragOffset({ x: deltaX, y: 0 });
          };

          const handleMouseUp = () => {
            if (!isDragging) return;
            
            const threshold = 100;
            if (Math.abs(dragOffset.x) > threshold) {
              handleResponse(dragOffset.x > 0);
            }
            
            setIsDragging(false);
            setDragOffset({ x: 0, y: 0 });
          };

          // Touch events for mobile
          const handleTouchStart = (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            setIsDragging(true);
            setStartPos({ x: touch.clientX, y: touch.clientY });
            setDragOffset({ x: 0, y: 0 });
          };

          const handleTouchMove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - startPos.x;
            setDragOffset({ x: deltaX, y: 0 });
          };

          const handleTouchEnd = () => {
            if (!isDragging) return;
            
            const threshold = 100;
            if (Math.abs(dragOffset.x) > threshold) {
              handleResponse(dragOffset.x > 0);
            }
            
            setIsDragging(false);
            setDragOffset({ x: 0, y: 0 });
          };

          const resetCurrentSet = () => {
            setScores(prev => {
              const newScores = { ...prev };
              currentSet.forEach(letter => {
                newScores[letter] = 0;
              });
              return newScores;
            });
            setCurrentCardIndex(0);
          };

          const clearAllData = () => {
            if (window.confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
              setScores({});
              setCurrentSet(['A', 'B', 'C', 'D', 'E']);
              setCurrentCardIndex(0);
              setSuccessThreshold(3);
              localStorage.removeItem('alphabet-flashcards-data');
            }
          };

          const generateNewSet = () => {
            // Get letters that need more practice (score < threshold)
            const needsPractice = allLetters.filter(letter => 
              (scores[letter] || 0) < successThreshold
            );
            
            if (needsPractice.length >= 5) {
              // Take first 5 letters that need practice
              setCurrentSet(needsPractice.slice(0, 5));
            } else {
              // Mix letters that need practice with new ones
              const practiced = allLetters.filter(letter => 
                (scores[letter] || 0) >= successThreshold
              );
              const remaining = allLetters.filter(letter => 
                !currentSet.includes(letter) && !practiced.includes(letter)
              );
              
              const newSet = [
                ...needsPractice,
                ...remaining.slice(0, 5 - needsPractice.length)
              ];
              
              if (newSet.length < 5) {
                // Fill with any letters if we're running low
                const filler = allLetters.filter(letter => !newSet.includes(letter));
                newSet.push(...filler.slice(0, 5 - newSet.length));
              }
              
              setCurrentSet(newSet.slice(0, 5));
            }
            setCurrentCardIndex(0);
          };

          const getCardStyle = () => {
            const rotation = dragOffset.x * 0.1;
            const opacity = Math.max(0.7, 1 - Math.abs(dragOffset.x) / 300);
            
            return {
              transform: `translate(${dragOffset.x}px, 0px) rotate(${rotation}deg)`,
              opacity: opacity,
              cursor: isDragging ? 'grabbing' : 'grab',
            };
          };

          // Simple icons using Unicode symbols
          const CheckIcon = () => <span className="text-2xl">✓</span>;
          const XIcon = () => <span className="text-2xl">✗</span>;
          const SettingsIcon = () => <span className="text-xl">⚙</span>;

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col items-center p-2 pt-8">
              {/* Header */}
              <div className="w-full max-w-md mb-4 flex justify-between items-center">
                <h1 className="text-xl font-bold text-gray-800">Alphabet Practice</h1>
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className="p-2 rounded-lg bg-white shadow-md hover:shadow-lg transition-shadow"
                >
                  <SettingsIcon />
                </button>
              </div>

              {/* Settings Panel */}
              {showSettings && (
                <div className="w-full max-w-md mb-4 p-4 bg-white rounded-xl shadow-lg">
                  <div className="space-y-4">
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Current Set</h3>
                      <div className="flex gap-2 mb-3">
                        {currentSet.map((letter, index) => (
                          <span
                            key={letter}
                            className={`w-10 h-10 rounded-lg border-2 flex items-center justify-center font-bold ${
                              index === currentCardIndex
                                ? 'bg-blue-500 text-white border-blue-500'
                                : 'bg-gray-100 border-gray-300'
                            }`}
                          >
                            {letter}
                          </span>
                        ))}
                      </div>
                      <div className="flex gap-2 flex-wrap">
                        <button
                          onClick={resetCurrentSet}
                          className="px-3 py-1 bg-yellow-500 text-white rounded-lg text-sm hover:bg-yellow-600 transition-colors"
                        >
                          Reset Current Set
                        </button>
                        <button
                          onClick={generateNewSet}
                          className="px-3 py-1 bg-green-500 text-white rounded-lg text-sm hover:bg-green-600 transition-colors"
                        >
                          New Set
                        </button>
                        <button
                          onClick={clearAllData}
                          className="px-3 py-1 bg-red-500 text-white rounded-lg text-sm hover:bg-red-600 transition-colors"
                        >
                          Clear All Progress
                        </button>
                      </div>
                    </div>
                    
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Settings</h3>
                      <div className="flex items-center gap-2">
                        <label className="text-sm">Success threshold:</label>
                        <select
                          value={successThreshold}
                          onChange={(e) => setSuccessThreshold(Number(e.target.value))}
                          className="px-2 py-1 border rounded text-sm"
                        >
                          <option value={2}>2 correct swipes</option>
                          <option value={3}>3 correct swipes</option>
                          <option value={4}>4 correct swipes</option>
                          <option value={5}>5 correct swipes</option>
                        </select>
                      </div>
                    </div>
                    
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Progress</h3>
                      <div className="grid grid-cols-6 gap-1">
                        {allLetters.map(letter => {
                          const score = scores[letter] || 0;
                          const isInCurrentSet = currentSet.includes(letter);
                          return (
                            <div
                              key={letter}
                              className={`w-8 h-8 rounded flex items-center justify-center text-xs font-bold ${
                                score >= successThreshold
                                  ? 'bg-green-500 text-white'
                                  : isInCurrentSet
                                  ? 'bg-blue-100 border-2 border-blue-500 text-blue-700'
                                  : 'bg-gray-100 text-gray-600'
                              }`}
                              title={`${letter}: ${score}/${successThreshold}`}
                            >
                              {letter}
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Progress for Current Set */}
              <div className="w-full max-w-md mb-4">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-medium text-gray-600">
                    Current Set Progress
                  </span>
                  <span className="text-sm text-gray-500">
                    {currentSet.filter(letter => (scores[letter] || 0) >= successThreshold).length} / {currentSet.length} mastered
                  </span>
                </div>
                <div className="flex gap-2">
                  {currentSet.map((letter, index) => {
                    const score = scores[letter] || 0;
                    const isCompleted = score >= successThreshold;
                    return (
                      <div key={letter} className="flex-1 text-center">
                        <div
                          className={`w-full h-2 rounded-full ${
                            isCompleted ? 'bg-green-500' : 'bg-gray-200'
                          }`}
                        >
                          {!isCompleted && (
                            <div
                              className="h-full bg-blue-500 rounded-full transition-all duration-300"
                              style={{ width: `${(score / successThreshold) * 100}%` }}
                            />
                          )}
                        </div>
                        <span className={`text-xs font-medium mt-1 block ${
                          index === currentCardIndex ? 'text-blue-600' : 'text-gray-500'
                        }`}>
                          {letter}
                        </span>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Flashcard */}
              <div className="relative w-full max-w-md mb-4">
                <div className="w-full aspect-square">
                  <div
                    ref={cardRef}
                    className="flashcard-container absolute inset-0 bg-white rounded-3xl shadow-2xl flex items-center justify-center border-4 border-gray-100"
                    style={getCardStyle()}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                  >
                    <div className="text-8xl font-bold text-gray-800 font-mono">
                      {currentLetter}
                    </div>
                    
                    {/* Drag indication */}
                    {isDragging && (
                      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-gray-400 text-sm">
                        Keep swiping...
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex gap-4">
                <button
                  onClick={() => handleResponse(false)}
                  className="px-6 py-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-colors flex items-center gap-2"
                >
                  <XIcon />
                  Try Again
                </button>
                <button
                  onClick={() => handleResponse(true)}
                  className="px-6 py-3 bg-green-500 text-white rounded-xl font-semibold hover:bg-green-600 transition-colors flex items-center gap-2"
                >
                  <CheckIcon />
                  Good Job!
                </button>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AlphabetFlashcards />);
    </script>
</body>
</html>
