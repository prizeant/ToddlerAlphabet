<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alphabet Flashcards</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: pan-y;
        }
        
        .flashcard-container {
            touch-action: none;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-20px);
            }
            60% {
                transform: translateY(-10px);
            }
        }
        
        .bounce {
            animation: bounce 1s;
        }
        
        @keyframes shake {
            10%, 90% {
                transform: translateX(-1px);
            }
            20%, 80% {
                transform: translateX(2px);
            }
            30%, 50%, 70% {
                transform: translateX(-4px);
            }
            40%, 60% {
                transform: translateX(4px);
            }
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        @keyframes confetti {
            0% {
                opacity: 1;
                transform: translateY(0) rotateZ(0);
            }
            100% {
                opacity: 0;
                transform: translateY(300px) rotateZ(360deg);
            }
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: confetti 2s forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const AlphabetFlashcards = () => {
          // Load saved data from localStorage
          const loadSavedData = () => {
            try {
              const savedData = localStorage.getItem('alphabet-flashcards-data');
              if (savedData) {
                const parsed = JSON.parse(savedData);
                return {
                  currentSet: parsed.currentSet || ['A', 'B', 'C', 'D', 'E'],
                  currentCardIndex: parsed.currentCardIndex || 0,
                  scores: parsed.scores || {},
                  letterStats: parsed.letterStats || {}, // Track difficulty and review timing
                  successThreshold: parsed.successThreshold || 5
                };
              }
            } catch (error) {
              console.log('Error loading saved data:', error);
            }
            return {
              currentSet: ['A', 'B', 'C', 'D', 'E'],
              currentCardIndex: 0,
              scores: {},
              letterStats: {},
              successThreshold: 5
            };
          };

          const savedData = loadSavedData();
          const [currentSet, setCurrentSet] = useState(savedData.currentSet);
          const [currentCardIndex, setCurrentCardIndex] = useState(savedData.currentCardIndex);
          const [scores, setScores] = useState(savedData.scores);
          const [letterStats, setLetterStats] = useState(savedData.letterStats);
          const [isDragging, setIsDragging] = useState(false);
          const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
          const [startPos, setStartPos] = useState({ x: 0, y: 0 });
          const [showSettings, setShowSettings] = useState(false);
          const [successThreshold, setSuccessThreshold] = useState(savedData.successThreshold);
          const [showCorrectFeedback, setShowCorrectFeedback] = useState(false);
          const [showWrongFeedback, setShowWrongFeedback] = useState(false);
          const [showCelebration, setShowCelebration] = useState(false);
          const cardRef = useRef(null);

          // Save data to localStorage whenever state changes
          const saveData = () => {
            try {
              const dataToSave = {
                currentSet,
                currentCardIndex,
                scores,
                letterStats,
                successThreshold,
                lastSaved: new Date().toISOString()
              };
              localStorage.setItem('alphabet-flashcards-data', JSON.stringify(dataToSave));
            } catch (error) {
              console.log('Error saving data:', error);
            }
          };

          // Auto-save when important data changes
          useEffect(() => {
            saveData();
          }, [currentSet, currentCardIndex, scores, letterStats, successThreshold]);

          // Spaced repetition helper functions
          const getDifficultyLevel = (letter) => {
            const stats = letterStats[letter];
            if (!stats) return 'new';
            
            const errorRate = stats.errors / (stats.attempts || 1);
            if (errorRate > 0.3) return 'hard';
            if (errorRate > 0.1) return 'medium';
            return 'easy';
          };
          
          const getNextReviewTime = (letter, wasCorrect) => {
            const now = Date.now();
            const difficulty = getDifficultyLevel(letter);
            const stats = letterStats[letter] || { interval: 1, easeFactor: 2.5 };
            
            let newInterval = stats.interval || 1;
            let newEaseFactor = stats.easeFactor || 2.5;
            
            if (wasCorrect) {
              // Increase interval based on difficulty
              if (difficulty === 'easy') {
                newInterval = Math.ceil(newInterval * 3); // Easy: 3 day multiplier
                newEaseFactor = Math.min(3.0, newEaseFactor + 0.1);
              } else if (difficulty === 'medium') {
                newInterval = Math.ceil(newInterval * 2); // Medium: 2 day multiplier
                newEaseFactor = Math.max(1.3, newEaseFactor);
              } else {
                newInterval = Math.ceil(newInterval * 1.5); // Hard: 1.5 day multiplier
                newEaseFactor = Math.max(1.3, newEaseFactor - 0.1);
              }
            } else {
              // Reset interval on wrong answer, but not to 1 if it was previously higher
              newInterval = Math.max(1, Math.ceil(newInterval * 0.5));
              newEaseFactor = Math.max(1.3, newEaseFactor - 0.2);
            }
            
            // Convert days to minutes for testing (in real use, you'd keep as days)
            const intervalMinutes = newInterval * 2; // 2 minutes per "day" for quick testing
            
            return {
              nextReview: now + (intervalMinutes * 60 * 1000),
              interval: newInterval,
              easeFactor: newEaseFactor
            };
          };
          
          const updateLetterStats = (letter, wasCorrect) => {
            const currentStats = letterStats[letter] || {
              attempts: 0,
              errors: 0,
              firstSeen: Date.now(),
              interval: 1,
              easeFactor: 2.5,
              nextReview: Date.now()
            };
            
            const reviewData = getNextReviewTime(letter, wasCorrect);
            
            setLetterStats(prev => ({
              ...prev,
              [letter]: {
                ...currentStats,
                attempts: currentStats.attempts + 1,
                errors: wasCorrect ? currentStats.errors : currentStats.errors + 1,
                interval: reviewData.interval,
                easeFactor: reviewData.easeFactor,
                nextReview: reviewData.nextReview,
                lastSeen: Date.now()
              }
            }));
          };
          
          const getLettersForReview = () => {
            const now = Date.now();
            
            // Get letters that need review (past their review time)
            const dueForReview = allLetters.filter(letter => {
              const stats = letterStats[letter];
              if (!stats) return true; // New letters are always due
              return now >= stats.nextReview;
            });
            
            // Sort by priority: hardest letters first, then by how overdue they are
            return dueForReview.sort((a, b) => {
              const statsA = letterStats[a] || {};
              const statsB = letterStats[b] || {};
              
              // Prioritize by difficulty (hard letters first)
              const diffA = getDifficultyLevel(a);
              const diffB = getDifficultyLevel(b);
              const diffOrder = { 'hard': 0, 'medium': 1, 'easy': 2, 'new': 3 };
              
              if (diffOrder[diffA] !== diffOrder[diffB]) {
                return diffOrder[diffA] - diffOrder[diffB];
              }
              
              // Then by how overdue they are
              const overdueA = now - (statsA.nextReview || 0);
              const overdueB = now - (statsB.nextReview || 0);
              return overdueB - overdueA;
            });
          };
          
          const currentLetter = currentSet[currentCardIndex];

          const handleResponse = (isCorrect) => {
            const letter = currentLetter;
            const currentScore = scores[letter] || 0;
            
            let newScore;
            if (isCorrect) {
              newScore = currentScore + 1;
              setShowCorrectFeedback(true);
              setTimeout(() => setShowCorrectFeedback(false), 1000);
              
              // Play correct sound
              try {
                const sound = document.getElementById('correct-sound');
                if (sound) sound.play().catch(e => console.log('Error playing sound:', e));
              } catch (e) {
                console.log('Error with audio:', e);
              }
            } else {
              newScore = 0; // Reset to 0 on wrong answer
              setShowWrongFeedback(true);
              setTimeout(() => setShowWrongFeedback(false), 700);
            }
            
            const updatedScores = {
              ...scores,
              [letter]: newScore
            };
            
            setScores(updatedScores);

            // Check if letter is now mastered
            if (newScore >= successThreshold) {
              // Show celebration
              setShowCelebration(true);
              setTimeout(() => setShowCelebration(false), 2000);
              
              // Play celebration sound
              try {
                const sound = document.getElementById('celebration-sound');
                if (sound) sound.play().catch(e => console.log('Error playing sound:', e));
              } catch (e) {
                console.log('Error with audio:', e);
              }
              
              // Replace the mastered letter with a new one
              const masteredLetterIndex = currentSet.indexOf(letter);
              const availableLetters = allLetters.filter(l => 
                !currentSet.includes(l) && (updatedScores[l] || 0) < successThreshold
              );
              
              if (availableLetters.length > 0) {
                // Replace with a new letter
                const newLetter = availableLetters[0];
                const newSet = [...currentSet];
                newSet[masteredLetterIndex] = newLetter;
                
                // Wait for celebration to finish before changing
                setTimeout(() => {
                  setCurrentSet(newSet);
                  setCurrentCardIndex((prev) => (prev + 1) % currentSet.length);
                }, 1500);
                return;
              }
            }

            // Move to next card (with slight delay if feedback is showing)
            setTimeout(() => {
              setCurrentCardIndex((prev) => (prev + 1) % currentSet.length);
            }, isCorrect ? 800 : 500);
          };

          const handleMouseDown = (e) => {
            setIsDragging(true);
            setStartPos({ x: e.clientX, y: e.clientY });
            setDragOffset({ x: 0, y: 0 });
          };

          const handleMouseMove = (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - startPos.x;
            setDragOffset({ x: deltaX, y: 0 });
          };

          const handleMouseUp = () => {
            if (!isDragging) return;
            
            const threshold = 100;
            if (Math.abs(dragOffset.x) > threshold) {
              handleResponse(dragOffset.x > 0);
            }
            
            setIsDragging(false);
            setDragOffset({ x: 0, y: 0 });
          };

          // Touch events for mobile
          const handleTouchStart = (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            setIsDragging(true);
            setStartPos({ x: touch.clientX, y: touch.clientY });
            setDragOffset({ x: 0, y: 0 });
          };

          const handleTouchMove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - startPos.x;
            setDragOffset({ x: deltaX, y: 0 });
          };

          const handleTouchEnd = () => {
            if (!isDragging) return;
            
            const threshold = 100;
            if (Math.abs(dragOffset.x) > threshold) {
              handleResponse(dragOffset.x > 0);
            }
            
            setIsDragging(false);
            setDragOffset({ x: 0, y: 0 });
          };

          const resetCurrentSet = () => {
            setScores(prev => {
              const newScores = { ...prev };
              currentSet.forEach(letter => {
                newScores[letter] = 0;
              });
              return newScores;
            });
            setCurrentCardIndex(0);
          };

          const clearAllData = () => {
            if (window.confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
              setScores({});
              setLetterStats({});
              setCurrentSet(['A', 'B', 'C', 'D', 'E']);
              setCurrentCardIndex(0);
              setSuccessThreshold(5);
              localStorage.removeItem('alphabet-flashcards-data');
            }
          };

          const generateSpacedRepetitionSet = () => {
            const lettersForReview = getLettersForReview();
            
            // Take up to 5 letters that are due for review
            let newSet = lettersForReview.slice(0, 5);
            
            // If we don't have 5 letters due for review, fill with new letters
            if (newSet.length < 5) {
              const newLetters = allLetters.filter(letter => 
                !letterStats[letter] && !newSet.includes(letter)
              );
              newSet = [...newSet, ...newLetters.slice(0, 5 - newSet.length)];
            }
            
            // If still don't have 5, add some easier letters that aren't quite due yet
            if (newSet.length < 5) {
              const almostDueLetters = allLetters.filter(letter => {
                const stats = letterStats[letter];
                if (!stats || newSet.includes(letter)) return false;
                const timeTillDue = stats.nextReview - Date.now();
                return timeTillDue < (24 * 60 * 60 * 1000); // Due within a day
              });
              newSet = [...newSet, ...almostDueLetters.slice(0, 5 - newSet.length)];
            }
            
            // Fallback: if still not enough, add any letters
            if (newSet.length < 5) {
              const remainingLetters = allLetters.filter(letter => !newSet.includes(letter));
              newSet = [...newSet, ...remainingLetters.slice(0, 5 - newSet.length)];
            }
            
            setCurrentSet(newSet.slice(0, 5));
            setCurrentCardIndex(0);
          };

          const generateNewSet = () => {
            generateSpacedRepetitionSet();
          };

          const getCardStyle = () => {
            const rotation = dragOffset.x * 0.1;
            const opacity = Math.max(0.7, 1 - Math.abs(dragOffset.x) / 300);
            
            return {
              transform: `translate(${dragOffset.x}px, 0px) rotate(${rotation}deg)`,
              opacity: opacity,
              cursor: isDragging ? 'grabbing' : 'grab',
            };
          };

          // Simple icons using Unicode symbols
          const CheckIcon = () => <span className="text-2xl">âœ“</span>;
          const XIcon = () => <span className="text-2xl">âœ—</span>;
          const SettingsIcon = () => <span className="text-xl">âš™</span>;

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 flex flex-col items-center p-2 pt-8">
              {/* Header */}
              <div className="w-full max-w-md mb-4 flex justify-between items-center">
                <h1 className="text-xl font-bold text-gray-800">Alphabet Practice</h1>
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className="p-2 rounded-lg bg-white shadow-md hover:shadow-lg transition-shadow"
                >
                  <SettingsIcon />
                </button>
              </div>

              {/* Settings Panel */}
              {showSettings && (
                <div className="w-full max-w-md mb-4 p-4 bg-white rounded-xl shadow-lg">
                  <div className="space-y-4">
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Current Set</h3>
                      <div className="flex gap-2 mb-3">
                        {currentSet.map((letter, index) => (
                          <span
                            key={letter}
                            className={`w-10 h-10 rounded-lg border-2 flex items-center justify-center font-bold ${
                              index === currentCardIndex
                                ? 'bg-blue-500 text-white border-blue-500'
                                : 'bg-gray-100 border-gray-300'
                            }`}
                          >
                            {letter}
                          </span>
                        ))}
                      </div>
                      <div className="flex gap-2 flex-wrap">
                        <button
                          onClick={resetCurrentSet}
                          className="px-3 py-1 bg-yellow-500 text-white rounded-lg text-sm hover:bg-yellow-600 transition-colors"
                        >
                          Reset Current Set
                        </button>
                        <button
                          onClick={generateNewSet}
                          className="px-3 py-1 bg-green-500 text-white rounded-lg text-sm hover:bg-green-600 transition-colors"
                        >
                          New Set
                        </button>
                        <button
                          onClick={clearAllData}
                          className="px-3 py-1 bg-red-500 text-white rounded-lg text-sm hover:bg-red-600 transition-colors"
                        >
                          Clear All Progress
                        </button>
                      </div>
                    </div>
                    
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Settings</h3>
                      <div className="flex items-center gap-2">
                        <label className="text-sm">Success threshold:</label>
                        <select
                          value={successThreshold}
                          onChange={(e) => setSuccessThreshold(Number(e.target.value))}
                          className="px-2 py-1 border rounded text-sm"
                        >
                          <option value={3}>3 correct swipes</option>
                          <option value={4}>4 correct swipes</option>
                          <option value={5}>5 correct swipes</option>
                          <option value={6}>6 correct swipes</option>
                        </select>
                      </div>
                    </div>
                    
                    <div>
                      <h3 className="text-lg font-semibold mb-2">Progress & Difficulty</h3>
                      <div className="grid grid-cols-6 gap-1">
                        {allLetters.map(letter => {
                          const score = scores[letter] || 0;
                          const isInCurrentSet = currentSet.includes(letter);
                          const difficulty = getDifficultyLevel(letter);
                          const stats = letterStats[letter];
                          
                          let bgClass = 'bg-gray-100 text-gray-600';
                          if (score >= successThreshold) {
                            bgClass = 'bg-green-500 text-white';
                          } else if (isInCurrentSet) {
                            bgClass = 'bg-blue-100 border-2 border-blue-500 text-blue-700';
                          } else if (difficulty === 'hard') {
                            bgClass = 'bg-red-100 text-red-700';
                          } else if (difficulty === 'medium') {
                            bgClass = 'bg-yellow-100 text-yellow-700';
                          }
                          
                          const nextReview = stats?.nextReview;
                          const isDue = nextReview && Date.now() >= nextReview;
                          
                          return (
                            <div
                              key={letter}
                              className={`w-8 h-8 rounded flex items-center justify-center text-xs font-bold ${bgClass} ${isDue ? 'ring-2 ring-purple-400' : ''}`}
                              title={`${letter}: ${score}/${successThreshold} | Difficulty: ${difficulty} | ${stats ? `Attempts: ${stats.attempts}, Errors: ${stats.errors}` : 'New'} ${isDue ? '| DUE NOW' : ''}`}
                            >
                              {letter}
                            </div>
                          );
                        })}
                      </div>
                      <div className="mt-2 text-xs text-gray-500">
                        <div>ðŸŸ¢ Mastered  ðŸ”µ Current Set  ðŸŸ¡ Medium  ðŸ”´ Hard  â­• Due for Review</div>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Progress for Current Set */}
              <div className="w-full max-w-md mb-4">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-medium text-gray-600">
                    Current Set Progress
                  </span>
                  <span className="text-sm text-gray-500">
                    {currentSet.filter(letter => (scores[letter] || 0) >= successThreshold).length} / {currentSet.length} mastered
                  </span>
                </div>
                <div className="flex gap-2">
                  {currentSet.map((letter, index) => {
                    const score = scores[letter] || 0;
                    const isCompleted = score >= successThreshold;
                    return (
                      <div key={letter} className="flex-1 text-center">
                        <div
                          className={`w-full h-2 rounded-full ${
                            isCompleted ? 'bg-green-500' : 'bg-gray-200'
                          }`}
                        >
                          {!isCompleted && (
                            <div
                              className="h-full bg-blue-500 rounded-full transition-all duration-300"
                              style={{ width: `${(score / successThreshold) * 100}%` }}
                            />
                          )}
                        </div>
                        <span className={`text-xs font-medium mt-1 block ${
                          index === currentCardIndex ? 'text-blue-600' : 'text-gray-500'
                        }`}>
                          {letter}
                        </span>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Flashcard */}
              <div className="relative w-full max-w-md mb-4">
                <div className="w-full aspect-square">
                  <div
                    ref={cardRef}
                    className={`flashcard-container absolute inset-0 bg-white rounded-3xl shadow-2xl flex items-center justify-center border-4 border-gray-100 ${showCorrectFeedback ? 'bounce' : ''} ${showWrongFeedback ? 'shake' : ''}`}
                    style={getCardStyle()}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                  >
                    <div className="text-8xl font-bold text-gray-800 font-mono">
                      {currentLetter}
                    </div>
                    
                    {/* Drag indication */}
                    {isDragging && (
                      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-gray-400 text-sm">
                        Keep swiping...
                      </div>
                    )}
                    
                    {/* Success feedback overlay */}
                    {showCorrectFeedback && (
                      <div className="absolute inset-0 bg-green-200 bg-opacity-30 rounded-3xl flex items-center justify-center">
                        {/* No text overlay */}
                      </div>
                    )}
                    
                    {/* Celebration confetti */}
                    {showCelebration && (
                      <div className="absolute inset-0 overflow-hidden rounded-3xl">
                        {Array.from({ length: 50 }).map((_, i) => {
                          const randomLeft = Math.random() * 100;
                          const randomDelay = Math.random() * 0.5;
                          const randomColor = ['#FF5252', '#FFD740', '#64FFDA', '#536DFE', '#8C9EFF'][Math.floor(Math.random() * 5)];
                          
                          return (
                            <div 
                              key={i}
                              className="confetti"
                              style={{
                                left: `${randomLeft}%`,
                                top: '-10px',
                                backgroundColor: randomColor,
                                animationDelay: `${randomDelay}s`,
                              }}
                            />
                          );
                        })}
                        {/* No text overlay here either */}
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex gap-4">
                <button
                  onClick={() => handleResponse(false)}
                  className="px-6 py-3 bg-red-500 text-white rounded-xl font-semibold hover:bg-red-600 transition-colors flex items-center gap-2"
                >
                  <XIcon />
                  Try Again
                </button>
                <button
                  onClick={() => handleResponse(true)}
                  className="px-6 py-3 bg-green-500 text-white rounded-xl font-semibold hover:bg-green-600 transition-colors flex items-center gap-2"
                >
                  <CheckIcon />
                  Good Job!
                </button>
              </div>
              
              {/* Sound effects (hidden) */}
              <audio id="correct-sound" preload="auto">
                <source src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" type="audio/ogg" />
              </audio>
              <audio id="celebration-sound" preload="auto">
                <source src="https://actions.google.com/sounds/v1/cartoon/crazy_celebration.ogg" type="audio/ogg" />
              </audio>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AlphabetFlashcards />);
    </script>
</body>
</html>
